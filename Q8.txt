#Primeiro
O primeiro código é um Bubble Sort,se o array iniciar 
ordenado de forma decrescente, entra no pior caso,
porque acontecerá uma comparação e uma troca em cada iteração no loop interno.
O pior caso ficaria com complexidade O (N^2)

No caso médio, assumimos que a lista parcialmente ordenada, sendo assim, 
o número de comparações e trocas realizadas vai depender da ordem específica da lista. 
Mas no geral, no caso médio é considerado O(n^2).

No melhor caso, a lista já está ordenada, assim, o algoritmo não vai 
fazer nenhuma troca, tendo complexidade no melhor caso é O(n).

#Segundo
Este código faz uma busca que funciona descartando um terço da lista em cada iteração,
o algoritmo verifica se a lista tem apenas um elemento. Se for o caso, retorna o elemento.
Então o algoritmo obtém o maior elemento da lista e então descarta 2/5 da lista, deixando apenas 3/5 da lista,
por fim chama recursivamente a si mesmo, passando a lista de 3/5 dos elementos.

No pior caso, a lista é ordenada de forma crescente, assim, o algoritmo descartará 2/5 da lista em cada iteração,
assim, o número de iterações será log(n)/log(3). O número total de comparações deve ser O(n * log(n)/log(3)).

No caso médio, levando em conta a chamada recursiva e como ela funciona em cada chamada, 
a complexidade média seria semelhante ao pior caso.

No melhor caso, o elemento procurado é o maior elemento da lista. Dessa forma, será retornado o elemento na primeira iteração. 
Portanto, o número de iterações será 1 e o número total de comparações realizadas pelo algoritmo será O(1).

#Terceira

A função Pesquisa3 implementa um algoritmo de divisão e conquista. logo após ele faz uma verificação, se o tamanho da lista (n) for menor ou igual a 1, 
a função retorna imediatamente.  Então faz uma ordenação quando n for maior que 1. Após a ordenação, aproximadamente 1/3 dos elementos são descartados, 
e a função faz uma chamada recursiva com o restante da lista. No pior caso, essa chamada recursiva continuará até que reste apenas um elemento na lista, 
resultando em O(log⁡ n) chamadas recursivas. Cada chamada recursiva executa a função Enigma2 com uma sublista de tamanho variável. 
No pior caso, Enigma2 precisa percorrer toda a sublista, realizando  O(n) comparações. Portanto, a complexidade total no pior caso do algoritmo implementado 
por Pesquisa3 é dominada pela complexidade da ordenação,  esultando em O(nlogn). Essa análise leva em consideração 
o pior cenário em que a chamada recursiva é feita até a lista ter apenas um elemento.

Temos assim: 

Pesquisa3:

Pior caso: O(n log(n))
Melhor caso: O(n)
Caso médio: O(n log(n))

Enigma1:

Pior caso: O(n log(n))
Melhor caso: O(n)
Caso médio: O(n log(n))

Enigma2:

Pior caso: O(n)
Melhor caso: O(1)
Caso médio: O(log(n))
